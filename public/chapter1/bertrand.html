<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>贝特朗悖论的可视化</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 12.5px;
            /* 比之前增大25% (10px × 1.25) */
            background: linear-gradient(135deg, #f5f7fa 0%, #e4edf5 100%);
        }

        header {
            text-align: center;
            margin-bottom: 18.75px;
            /* 增大25% (15px × 1.25) */
            padding: 18.75px;
            /* 增大25% (15px × 1.25) */
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 6.25px;
            /* 增大25% (5px × 1.25) */
            font-size: 2.25em;
            /* 增大25% (1.8em × 1.25) */
        }

        .subtitle {
            color: #7f8c8d;
            font-size: 1.25em;
            /* 增大25% (1em × 1.25) */
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 18.75px;
            /* 增大25% (15px × 1.25) */
        }

        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
            }
        }

        .visualization {
            background: white;
            border-radius: 10px;
            padding: 18.75px;
            /* 增大25% (15px × 1.25) */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            grid-column: 1 / -1;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 12.5px;
            /* 增大25% (10px × 1.25) */
            margin-bottom: 18.75px;
            /* 增大25% (15px × 1.25) */
            flex-wrap: wrap;
        }

        button {
            background: rgba(37, 99, 235, 1);
            color: white;
            border: none;
            padding: 10px 20px;
            /* 恢复为原始大小 */
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            /* 恢复为原始大小 */
            transition: all 0.3s ease;
        }

        button:hover {
            background: rgba(37, 99, 235, 1);
            transform: translateY(-2px);
        }

        button.active {
            background: rgba(231, 76, 60, 1);
            box-shadow: 0 4px 8px rgba(231, 76, 60, 0.3);
        }

        .canvas-container {
            position: relative;
            margin: 0 auto;
            width: 500px;
            /* 增大25% (400px × 1.25) */
            height: 500px;
            /* 增大25% (400px × 1.25) */
        }

        canvas {
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            width: 100%;
            height: 100%;
        }

        /* 以下是其他CSS样式，保持不变 */
        .methods {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 900px) {
            .methods {
                grid-template-columns: 1fr;
            }
        }

        .method {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }

        .method:hover {
            transform: translateY(-5px);
        }

        .method h3 {
            color: #2c3e50;
            border-bottom: 2px solid #2563eb;
            padding-bottom: 10px;
            margin-top: 0;
        }

        .probability {
            font-size: 1.5em;
            font-weight: bold;
            color: rgba(231, 76, 60, 1);
            text-align: center;
            margin: 15px 0;
        }

        .explanation {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid #2563eb;
        }

        .results {
            display: flex;
            justify-content: space-around;
            margin-top: 18.75px;
            /* 增大25% (15px × 1.25) */
            background: white;
            padding: 12.5px;
            /* 增大25% (10px × 1.25) */
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            font-size: 1.1em;
            /* 稍微增大字体大小 */
        }

        .result-item {
            text-align: center;
        }

        .result-value {
            font-weight: bold;
            font-size: 1.2em;
            /* 稍微增大字体大小 */
            color: rgba(37, 99, 235, 1);
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 18.75px;
            /* 增大25% (15px × 1.25) */
            margin-top: 12.5px;
            /* 增大25% (10px × 1.25) */
            margin-bottom: 12.5px;
            /* 增大25% (10px × 1.25) */
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 1em;
            /* 增大25% (0.9em × 1.25 ≈ 1.125em，这里取1em) */
        }

        .legend-color {
            width: 20px;
            /* 增大25% (16px × 1.25) */
            height: 20px;
            /* 增大25% (16px × 1.25) */
            border-radius: 4px;
        }

        .long {
            background-color: rgba(46, 204, 113, 1);
        }

        .short {
            background-color: rgba(231, 76, 60, 1);
        }

        .theory {
            margin-top: 25px;
            /* 增大25% (20px × 1.25) */
            background: white;
            padding: 25px;
            /* 增大25% (20px × 1.25) */
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .theory h2 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        footer {
            text-align: center;
            margin-top: 25px;
            /* 增大25% (20px × 1.25) */
            padding: 18.75px;
            /* 增大25% (15px × 1.25) */
            color: #7f8c8d;
            font-size: 0.9em;
        }
    </style>
</head>

<body>

    <div class="container">
        <div class="visualization">
            <div class="controls">
                <button id="method1" class="active">随机端点法</button>
                <button id="method2">随机半径法</button>
                <button id="method3">随机中点法</button>
                <button id="simulate">开始模拟</button>
                <button id="reset">重置</button>
            </div>

            <div class="canvas-container">
                <canvas id="paradoxCanvas" width="500" height="500"></canvas> <!-- 增大25% (400px × 1.25) -->
            </div>

            <div class="results">
                <div class="result-item">
                    <div>当前方法:</div>
                    <div class="result-value" id="currentMethod">随机端点法</div>
                </div>
                <div class="result-item">
                    <div>模拟次数:</div>
                    <div class="result-value" id="simulationCount">0</div>
                </div>
                <div class="result-item">
                    <div>满足条件:</div>
                    <div class="result-value" id="successCount">0</div>
                </div>
                <div class="result-item">
                    <div>概率:</div>
                    <div class="result-value" id="probability">0.000</div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color long"></div>
                    <div>弦长 > √3 (满足条件)</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color short"></div>
                    <div>弦长 ≤ √3</div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // 获取Canvas元素和上下文
        const canvas = document.getElementById('paradoxCanvas');
        const ctx = canvas.getContext('2d');

        // 设置圆心和半径
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = 188; // 增大25% (150px × 1.25 = 187.5px，四舍五入为188px)

        // 临界弦长（内接等边三角形边长）
        const criticalLength = Math.sqrt(3);

        // 状态变量
        let currentMethod = 'method1';
        let simulationCount = 0;
        let successCount = 0;
        let simulationInterval = null;

        // 初始化绘图
        function initCanvas() {
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 绘制圆形
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 绘制圆心
            ctx.beginPath();
            ctx.arc(centerX, centerY, 3.75, 0, Math.PI * 2); // 增大25% (3px × 1.25)
            ctx.fillStyle = 'rgba(231, 76, 60, 1)';
            ctx.fill();

            // 绘制内接等边三角形
            drawEquilateralTriangle();
        }

        // 绘制内接等边三角形
        function drawEquilateralTriangle() {
            ctx.beginPath();

            // 计算三角形的三个顶点
            for (let i = 0; i < 3; i++) {
                const angle = Math.PI / 2 + i * 2 * Math.PI / 3;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.closePath();
            ctx.strokeStyle = 'rgba(37, 99, 235, 1)';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([5, 3]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // 方法1：随机端点法
        function method1() {
            // 在圆周上随机选择两个点
            const angle1 = Math.random() * 2 * Math.PI;
            const angle2 = Math.random() * 2 * Math.PI;

            const x1 = centerX + radius * Math.cos(angle1);
            const y1 = centerY + radius * Math.sin(angle1);
            const x2 = centerX + radius * Math.cos(angle2);
            const y2 = centerY + radius * Math.sin(angle2);

            // 计算弦长（欧氏距离）
            const dx = x2 - x1;
            const dy = y2 - y1;
            const chordLength = Math.sqrt(dx * dx + dy * dy) / radius; // 标准化为单位圆

            // 返回结果
            return {
                points: [{ x: x1, y: y1 }, { x: x2, y: y2 }],
                chordLength: chordLength,
                valid: chordLength > criticalLength
            };
        }

        // 方法2：随机半径法
        function method2() {
            // 随机选择一条半径
            const radiusAngle = Math.random() * 2 * Math.PI;

            // 在半径上随机选择一个点
            const distance = Math.random() * radius;

            // 计算该点坐标
            const px = centerX + distance * Math.cos(radiusAngle);
            const py = centerY + distance * Math.sin(radiusAngle);

            // 计算弦的两个端点
            // 弦的方向垂直于半径
            const chordAngle = radiusAngle + Math.PI / 2;

            // 计算弦长的一半（从圆心到弦的距离为distance）
            const halfChordLength = Math.sqrt(radius * radius - distance * distance);

            // 计算两个端点
            const x1 = px + halfChordLength * Math.cos(chordAngle);
            const y1 = py + halfChordLength * Math.sin(chordAngle);
            const x2 = px - halfChordLength * Math.cos(chordAngle);
            const y2 = py - halfChordLength * Math.sin(chordAngle);

            // 标准化弦长
            const chordLength = 2 * halfChordLength / radius;

            return {
                points: [{ x: x1, y: y1 }, { x: x2, y: y2 }],
                chordLength: chordLength,
                valid: chordLength > criticalLength
            };
        }

        // 方法3：随机中点法
        function method3() {
            // 在圆内随机选择一点作为弦的中点
            let mx, my;
            let distanceSquared;

            // 使用拒绝采样确保点在圆内
            do {
                mx = Math.random() * 2 * radius - radius;
                my = Math.random() * 2 * radius - radius;
                distanceSquared = mx * mx + my * my;
            } while (distanceSquared > radius * radius);

            // 调整坐标到画布中心
            const pointX = centerX + mx;
            const pointY = centerY + my;

            // 计算从圆心到中点的角度
            const angleToCenter = Math.atan2(my, mx);

            // 计算弦的方向（垂直于圆心到中点的线）
            const chordAngle = angleToCenter + Math.PI / 2;

            // 计算弦长的一半
            const halfChordLength = Math.sqrt(radius * radius - distanceSquared);

            // 计算两个端点
            const x1 = pointX + halfChordLength * Math.cos(chordAngle);
            const y1 = pointY + halfChordLength * Math.sin(chordAngle);
            const x2 = pointX - halfChordLength * Math.cos(chordAngle);
            const y2 = pointY - halfChordLength * Math.sin(chordAngle);

            // 标准化弦长
            const chordLength = 2 * halfChordLength / radius;

            return {
                points: [{ x: x1, y: y1 }, { x: x2, y: y2 }],
                chordLength: chordLength,
                midpoint: { x: pointX, y: pointY },
                valid: chordLength > criticalLength
            };
        }

        // 绘制弦
        function drawChord(result) {
            const points = result.points;

            // 设置弦的颜色（根据是否满足条件）
            ctx.strokeStyle = result.valid ? 'rgba(46, 204, 113, 1)' : 'rgba(231, 76, 60, 1)';
            ctx.lineWidth = 1.5;

            // 绘制弦
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            ctx.lineTo(points[1].x, points[1].y);
            ctx.stroke();

            // 如果是方法3，绘制中点
            if (currentMethod === 'method3' && result.midpoint) {
                ctx.fillStyle = result.valid ? 'rgba(46, 204, 113, 1)' : 'rgba(231, 76, 60, 1)';
                ctx.beginPath();
                ctx.arc(result.midpoint.x, result.midpoint.y, 3.75, 0, Math.PI * 2); // 增大25% (3px × 1.25)
                ctx.fill();
            }
        }

        // 执行一次模拟
        function runSimulation() {
            let result;

            // 根据当前方法选择相应的函数
            switch (currentMethod) {
                case 'method1':
                    result = method1();
                    break;
                case 'method2':
                    result = method2();
                    break;
                case 'method3':
                    result = method3();
                    break;
                default:
                    result = method1();
            }

            // 绘制弦
            drawChord(result);

            // 更新计数
            simulationCount++;
            if (result.valid) {
                successCount++;
            }

            // 更新UI
            updateUI();
        }

        // 更新UI显示
        function updateUI() {
            document.getElementById('simulationCount').textContent = simulationCount;
            document.getElementById('successCount').textContent = successCount;

            // 计算并显示概率
            const probability = simulationCount > 0 ? (successCount / simulationCount).toFixed(3) : '0.000';
            document.getElementById('probability').textContent = probability;

            // 更新当前方法显示
            let methodName = '';
            switch (currentMethod) {
                case 'method1':
                    methodName = '随机端点法';
                    break;
                case 'method2':
                    methodName = '随机半径法';
                    break;
                case 'method3':
                    methodName = '随机中点法';
                    break;
            }
            document.getElementById('currentMethod').textContent = methodName;
        }

        // 重置模拟
        function resetSimulation() {
            // 停止当前模拟
            if (simulationInterval) {
                clearInterval(simulationInterval);
                simulationInterval = null;
                document.getElementById('simulate').textContent = '开始模拟';
            }

            // 重置计数器
            simulationCount = 0;
            successCount = 0;

            // 重新初始化画布
            initCanvas();

            // 更新UI
            updateUI();
        }

        // 切换方法
        function switchMethod(method) {
            // 更新按钮状态
            document.querySelectorAll('.controls button').forEach(button => {
                button.classList.remove('active');
            });
            document.getElementById(method).classList.add('active');

            // 更新当前方法
            currentMethod = method;

            // 重置模拟
            resetSimulation();
        }

        // 开始/停止模拟
        function toggleSimulation() {
            const simulateButton = document.getElementById('simulate');

            if (simulationInterval) {
                // 停止模拟
                clearInterval(simulationInterval);
                simulationInterval = null;
                simulateButton.textContent = '开始模拟';
            } else {
                // 开始模拟
                simulationInterval = setInterval(runSimulation, 50);
                simulateButton.textContent = '停止模拟';
            }
        }

        // 事件监听器
        document.getElementById('method1').addEventListener('click', () => switchMethod('method1'));
        document.getElementById('method2').addEventListener('click', () => switchMethod('method2'));
        document.getElementById('method3').addEventListener('click', () => switchMethod('method3'));
        document.getElementById('simulate').addEventListener('click', toggleSimulation);
        document.getElementById('reset').addEventListener('click', resetSimulation);

        // 初始化
        window.onload = function () {
            initCanvas();
            updateUI();
        };
    </script>
</body>

</html>