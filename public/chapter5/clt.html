<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>高尔顿钉板实验 - 震动效果与暂停功能</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: #ffffff;
            color: #333333;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: none;
            /* 移除文字阴影 */
            background: #3b82f6;
            /* 替换渐变为纯蓝色 */
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            font-size: 1.3rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 30px;
        }

        .board-container {
            flex: 1;
            min-width: 600px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stats-container {
            flex: 1;
            min-width: 400px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
        }

        .section-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }

        #galtonBoard {
            background: #f5f5f5;
            width: 100%;
            height: 600px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.1);
        }

        .stats-row {
            display: flex;
            margin-bottom: 25px;
        }

        .stat-box {
            flex: 1;
            background: rgba(255, 255, 255, 0.8);
            /* 改为浅色半透明 */
            border-radius: 10px;
            padding: 15px;
            margin: 0 10px;
            text-align: center;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            /* 添加浅色阴影 */
        }

        .stat-box:hover {
            transform: translateY(-5px);
            background: rgba(0, 0, 0, 0.3);
        }

        .stat-value {
            font-size: 2.2rem;
            font-weight: bold;
            margin: 10px 0;
            color: #3b82f6;
            /* 改为蓝色 */
        }

        .stat-label {
            font-size: 1rem;
            opacity: 0.8;
        }

        .dist-container {
            flex: 1;
            position: relative;
        }

        #distributionChart {
            background: #f8f9fa;
            border-radius: 10px;
            width: 100%;
            height: 300px;
        }

        .controls {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
        }

        .control-group {
            flex: 1;
            min-width: 200px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #3b82f6;
            /* 改为蓝色轨道 */
            outline: none;
            appearance: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            box-shadow: 0 0 10px #3b82f6;
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .range-value {
            display: inline-block;
            width: 50px;
            text-align: right;
            font-weight: bold;
        }

        .buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            padding: 15px 20px;
            font-size: 1.1rem;
            background: #3b82f6;
            /* 蓝色按钮 */
            color: white;
            /* 白色文字 */
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 150px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            background: #2563eb;
            /* 深蓝色hover效果 */
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }

        button:active {
            transform: translateY(0);
        }

        .btn-reset {
            background: #ef4444;
            /* 保持红色重置按钮 */
        }

        .btn-reset:hover {
            background: #dc2626;
        }

        .btn-pause {
            background: #93c5fd;
            /* 浅蓝色暂停按钮 */
            color: #1a2a6c;
        }

        .btn-pause:hover {
            background: #60a5fa;
        }

        .explanation {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .explanation h2 {
            margin-bottom: 15px;
            font-size: 1.8rem;
            color: #4dccbd;
        }

        .explanation p {
            margin-bottom: 15px;
            line-height: 1.7;
            font-size: 1.1rem;
        }

        .key-points {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .point {
            background: rgba(255, 255, 255, 0.9);
            /* 改为浅色背景 */
            padding: 20px;
            border-radius: 10px;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .point:hover {
            transform: translateY(-5px);
            background: rgba(0, 0, 0, 0.3);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        .point h3 {
            color: #4dccbd;
            margin-bottom: 10px;
            font-size: 1.3rem;
        }

        .point p {
            font-size: 1rem;
        }

        .footer-note {
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        @media (max-width: 768px) {
            .content {
                flex-direction: column;
            }

            .board-container,
            .stats-container {
                min-width: 100%;
            }

            h1 {
                font-size: 2.2rem;
            }

            .subtitle {
                font-size: 1.1rem;
            }

            .buttons button {
                min-width: 100%;
            }
        }

        .release-indicator {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ff6b6b;
            box-shadow: 0 0 15px #ff6b6b;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .release-indicator.active {
            animation: pulse 0.8s ease-out;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
                transform: translateX(-50%) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateX(-50%) scale(1.8);
            }
        }

        .queue-display {
            position: absolute;
            background-color: #3b82f6;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            z-index: 10;
            font-weight: bold;
            color: white;
        }

        .queue-count {
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            margin-left: 8px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="content">
            <div class="board-container">
                <h2 class="section-title">钉板实验</h2>
                <div style="position: relative;">
                    <canvas id="galtonBoard"></canvas>
                    <div class="release-indicator" id="releaseIndicator"></div>
                    <div class="queue-display">
                        <span>等待释放:</span>
                        <div class="queue-count" id="queueCount">0</div>
                    </div>
                </div>
            </div>

            <div class="stats-container">
                <h2 class="section-title">分布统计</h2>

                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-label">总球数</div>
                        <div id="totalBalls" class="stat-value">0</div>
                    </div>

                    <div class="stat-box">
                        <div class="stat-label">当前速度</div>
                        <div id="currentSpeed" class="stat-value">1x</div>
                    </div>

                    <div class="stat-box">
                        <div class="stat-label">钉子层数</div>
                        <div id="pegLayers" class="stat-value">15</div>
                    </div>
                </div>

                <h3 class="section-title">分布曲线</h3>
                <div class="dist-container">
                    <canvas id="distributionChart"></canvas>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-row">
                <div class="control-group">
                    <label for="ballSpeed">下落速度: <span id="speedValue" class="range-value">3x</span></label>
                    <input type="range" id="ballSpeed" min="1" max="10" value="3">
                </div>

                <div class="control-group">
                    <label for="pegLayersSlider">钉子层数: <span id="layerValue" class="range-value">15</span></label>
                    <input type="range" id="pegLayersSlider" min="5" max="25" value="15">
                </div>

                <div class="control-group">
                    <label for="biasSlider">向右概率: <span id="biasValue" class="range-value">0.5</span></label>
                    <input type="range" id="biasSlider" min="0.3" max="0.7" step="0.05" value="0.5">
                </div>
            </div>

            <div class="buttons">
                <button id="dropBall">释放1个小球</button>
                <button id="drop10Balls">释放10个小球</button>
                <button id="drop100Balls">释放100个小球</button>
                <button id="drop500Balls">释放500个小球</button>
                <button id="startAuto" class="btn-reset">自动释放</button>
                <button id="pauseBtn" class="btn-pause">暂停</button>
                <button id="resetBtn" class="btn-reset">重置实验</button>
            </div>
        </div>


    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // 获取Canvas元素和上下文
            const boardCanvas = document.getElementById('galtonBoard');
            const distCanvas = document.getElementById('distributionChart');
            const boardCtx = boardCanvas.getContext('2d');
            const distCtx = distCanvas.getContext('2d');
            const releaseIndicator = document.getElementById('releaseIndicator');
            const queueCount = document.getElementById('queueCount');

            // 设置Canvas尺寸
            boardCanvas.width = boardCanvas.offsetWidth;
            boardCanvas.height = boardCanvas.offsetHeight;
            distCanvas.width = distCanvas.offsetWidth;
            distCanvas.height = distCanvas.offsetHeight;

            // 实验参数
            let config = {
                rows: 15,  // 增加默认层数
                cols: 16,  // 收集槽数量 = 层数 + 1
                ballRadius: 8,
                pegRadius: 6,
                speed: 3,
                gravity: 0.2,
                bias: 0.5,
                balls: [],
                bins: [],
                autoMode: false,
                totalBalls: 0,
                animationId: null,
                binY: 0,
                maxBins: 1,
                binWidth: 0,
                ballQueue: 0, // 等待释放的小球数量
                releaseInterval: 200, // 小球释放间隔(毫秒)
                lastReleaseTime: 0, // 上次释放小球的时间
                paused: false // 新增暂停状态
            };

            // 钉子和收集槽的位置
            let pegs = [];
            let bins = [];
            let pegsByRow = []; // 按行组织的钉子

            // 初始化实验
            function initExperiment() {
                config.balls = [];
                config.bins = new Array(config.cols).fill(0);
                config.totalBalls = 0;
                config.maxBins = 1;
                config.ballQueue = 0;
                config.paused = false; // 重置暂停状态
                document.getElementById('pauseBtn').textContent = '暂停';
                document.getElementById('pauseBtn').style.background = '#f7c948';
                queueCount.textContent = '0';

                // 更新UI
                document.getElementById('totalBalls').textContent = config.totalBalls;
                document.getElementById('currentSpeed').textContent = config.speed + 'x';
                document.getElementById('pegLayers').textContent = config.rows;

                // 计算钉板尺寸参数
                const boardWidth = boardCanvas.width;
                const boardHeight = boardCanvas.height;
                config.binY = boardHeight * 0.85;

                // 计算钉子的位置
                pegs = [];
                pegsByRow = [];
                const pegSpacingX = boardWidth / (config.rows + 1);
                const pegSpacingY = (boardHeight * 0.7) / config.rows;

                for (let row = 0; row < config.rows; row++) {
                    const y = 80 + row * pegSpacingY;
                    const pegsInRow = row + 1;
                    const startX = (boardWidth - (pegsInRow - 1) * pegSpacingX) / 2;

                    pegsByRow[row] = [];

                    for (let col = 0; col < pegsInRow; col++) {
                        const x = startX + col * pegSpacingX;
                        const peg = {
                            x,
                            y,
                            radius: config.pegRadius,
                            row: row
                        };
                        pegs.push(peg);
                        pegsByRow[row].push(peg);
                    }
                }

                // 计算收集槽的位置
                bins = [];
                config.binWidth = boardWidth / config.cols;
                const binHeight = boardHeight * 0.15;

                for (let i = 0; i < config.cols; i++) {
                    bins.push({
                        x: i * config.binWidth,
                        y: config.binY,
                        width: config.binWidth,
                        height: binHeight,
                        count: 0
                    });
                }

                // 绘制初始状态
                drawBoard();
                drawDistribution();
            }

            // 绘制钉板
            function drawBoard() {
                boardCtx.clearRect(0, 0, boardCanvas.width, boardCanvas.height);

                // 绘制渐变背景
                const gradient = boardCtx.createLinearGradient(0, 0, boardCanvas.width, boardCanvas.height);
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(1, '#ffffff');
                boardCtx.fillStyle = gradient;
                boardCtx.fillRect(0, 0, boardCanvas.width, boardCanvas.height);

                // 绘制网格线
                boardCtx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
                boardCtx.lineWidth = 1;

                // 绘制收集槽柱状图
                bins.forEach((bin, index) => {
                    // 计算柱状图高度
                    const barHeight = (config.bins[index] / config.maxBins) * bin.height * 0.9;

                    // 绘制柱状图
                    const barX = bin.x + bin.width * 0.1;
                    const barY = bin.y + bin.height - barHeight;
                    const barWidth = bin.width * 0.8;

                    // 柱状图渐变效果
                    const barGradient = boardCtx.createLinearGradient(0, barY, 0, barY + barHeight);
                    barGradient.addColorStop(0, '#3b82f6');
                    barGradient.addColorStop(1, '#3b82f6');

                    boardCtx.fillStyle = barGradient;
                    boardCtx.fillRect(barX, barY, barWidth, barHeight);

                    // 绘制柱状图边框
                    boardCtx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    boardCtx.lineWidth = 1;
                    boardCtx.strokeRect(barX, barY, barWidth, barHeight);

                    // 在柱状图上方显示数字
                    if (config.bins[index] > 0) {
                        boardCtx.fillStyle = 'black';
                        boardCtx.font = '14px Arial';
                        boardCtx.textAlign = 'center';
                        boardCtx.fillText(config.bins[index].toString(), barX + barWidth / 2, barY - 10);
                    }
                });

                // 绘制收集槽分隔线
                boardCtx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                boardCtx.lineWidth = 1;
                bins.forEach(bin => {
                    boardCtx.strokeRect(bin.x, bin.y, bin.width, bin.height);
                });

                // 绘制钉子
                boardCtx.fillStyle = '#333333';
                pegs.forEach(peg => {
                    // 钉子阴影
                    boardCtx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    boardCtx.shadowBlur = 5;
                    boardCtx.shadowOffsetX = 2;
                    boardCtx.shadowOffsetY = 2;

                    boardCtx.beginPath();
                    boardCtx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);
                    boardCtx.fill();

                    // 重置阴影
                    boardCtx.shadowColor = 'transparent';
                    boardCtx.shadowBlur = 0;
                    boardCtx.shadowOffsetX = 0;
                    boardCtx.shadowOffsetY = 0;
                    boardCtx.fillStyle = '#333333';
                });

                // 绘制下落的小球
                config.balls.forEach(ball => {
                    // 小球阴影
                    boardCtx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    boardCtx.shadowBlur = 8;
                    boardCtx.shadowOffsetX = 2;
                    boardCtx.shadowOffsetY = 2;

                    // 绘制小球
                    boardCtx.fillStyle = ball.color;
                    boardCtx.beginPath();
                    boardCtx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                    boardCtx.fill();

                    // 绘制小球高光
                    boardCtx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    boardCtx.beginPath();
                    boardCtx.arc(ball.x - ball.radius / 3, ball.y - ball.radius / 3, ball.radius / 3, 0, Math.PI * 2);
                    boardCtx.fill();

                    // 重置阴影
                    boardCtx.shadowColor = 'transparent';
                    boardCtx.shadowBlur = 0;
                    boardCtx.shadowOffsetX = 0;
                    boardCtx.shadowOffsetY = 0;
                });

                // 绘制标题

                // 显示暂停状态
                if (config.paused) {
                    boardCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    boardCtx.font = 'bold 40px Arial';
                    boardCtx.fillText('已暂停', boardCanvas.width / 2, boardCanvas.height / 2);
                }
            }

            // 绘制分布图
            function drawDistribution() {
                distCtx.clearRect(0, 0, distCanvas.width, distCanvas.height);

                // 绘制渐变背景
                const gradient = distCtx.createLinearGradient(0, 0, distCanvas.width, distCanvas.height);
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(1, '#ffffff');
                distCtx.fillStyle = gradient;
                distCtx.fillRect(0, 0, distCanvas.width, distCanvas.height);

                // 绘制网格线
                distCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                distCtx.lineWidth = 1;

                // 水平网格线
                for (let i = 0; i <= 5; i++) {
                    const y = i * (distCanvas.height / 5);
                    distCtx.beginPath();
                    distCtx.moveTo(0, y);
                    distCtx.lineTo(distCanvas.width, y);
                    distCtx.stroke();
                }

                // 垂直网格线（对应收集槽）
                for (let i = 0; i < config.cols; i++) {
                    const x = i * (distCanvas.width / config.cols);
                    distCtx.beginPath();
                    distCtx.moveTo(x, 0);
                    distCtx.lineTo(x, distCanvas.height);
                    distCtx.stroke();
                }

                // 如果没有小球，直接返回
                if (config.totalBalls === 0) return;

                // 计算最大槽中小球数量用于缩放
                const maxBalls = Math.max(...config.bins);
                const binWidth = distCanvas.width / config.cols;

                // 绘制二项分布柱状图
                for (let i = 0; i < config.cols; i++) {
                    const binHeight = (config.bins[i] / maxBalls) * distCanvas.height * 0.8;
                    const x = i * binWidth + binWidth * 0.1;
                    const y = distCanvas.height - binHeight;
                    const width = binWidth * 0.8;

                    // 绘制柱状图
                    const gradient = distCtx.createLinearGradient(x, y, x, distCanvas.height);
                    gradient.addColorStop(0, '#3b82f6');
                    gradient.addColorStop(1, '#3b82f6');

                    distCtx.fillStyle = gradient;
                    distCtx.fillRect(x, y, width, binHeight);

                    // 绘制柱状图边框
                    distCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    distCtx.lineWidth = 1;
                    distCtx.strokeRect(x, y, width, binHeight);

                    // 绘制柱状图上的数字
                    if (config.bins[i] > 0) {
                        distCtx.fillStyle = 'black';
                        distCtx.font = '12px Arial';
                        distCtx.textAlign = 'center';
                        distCtx.fillText(config.bins[i], x + width / 2, y - 5);
                    }
                }

                // 绘制正态分布曲线
                distCtx.beginPath();
                distCtx.strokeStyle = '#ff6b6b';
                distCtx.lineWidth = 3;
                distCtx.shadowColor = '#ff6b6b';
                distCtx.shadowBlur = 10;

                // 修正对称轴位置 - 使用正确的二项分布参数
                const n = config.rows; // 试验次数 = 钉子层数
                const p = config.bias; // 每次试验成功概率
                const mean = n * p; // 二项分布均值 μ = n·p
                const stdDev = Math.sqrt(n * p * (1 - p)); // 二项分布标准差 σ = √(n·p·(1-p))

                // 计算曲线的缩放比例
                const maxDensity = normalPDF(mean, mean, stdDev);
                const scaleFactor = (distCanvas.height * 0.8) / maxDensity;

                // 绘制曲线
                const points = 200;
                for (let i = 0; i <= points; i++) {
                    const xPos = i * (distCanvas.width / points);
                    // 将画布坐标转换为分布值 (0 到 cols-1)
                    const binValue = (xPos / distCanvas.width) * (config.cols - 1);

                    // 计算正态分布值
                    const normalValue = normalPDF(binValue, mean, stdDev) * scaleFactor;
                    const y = distCanvas.height - normalValue;

                    if (i === 0) {
                        distCtx.moveTo(xPos, y);
                    } else {
                        distCtx.lineTo(xPos, y);
                    }
                }

                distCtx.stroke();
                distCtx.shadowBlur = 0;

                // 绘制对称轴（理论均值位置）
                const meanX = (mean / (config.cols - 1)) * distCanvas.width;
                distCtx.beginPath();
                distCtx.strokeStyle = '#3b82f6';
                distCtx.setLineDash([5, 3]);
                distCtx.lineWidth = 1;
                distCtx.moveTo(meanX, 0);
                distCtx.lineTo(meanX, distCanvas.height);
                distCtx.stroke();
                distCtx.setLineDash([]);

                // 绘制标题
                distCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                distCtx.font = 'bold 16px Arial';
                distCtx.textAlign = 'center';
                distCtx.fillText('正态分布曲线 (理论均值: ' + mean.toFixed(1) + ')', distCanvas.width / 2, 20);
            }

            // 正态分布概率密度函数
            function normalPDF(x, mean, stdDev) {
                const exponent = -Math.pow(x - mean, 2) / (2 * Math.pow(stdDev, 2));
                return (1 / (stdDev * Math.sqrt(2 * Math.PI))) * Math.exp(exponent);
            }

            // 添加小球
            function addBall() {
                // 在顶部中间位置添加小球
                const startX = boardCanvas.width / 2;
                const ball = {
                    x: startX,
                    y: 30,
                    radius: config.ballRadius,
                    color: `hsl(${Math.random() * 360}, 80%, 60%)`,
                    row: 0, // 当前所在行
                    lastCollisionRow: -1, // 上一次碰撞的行
                    velocityY: 0, // 新增垂直速度
                    velocityX: 0, // 新增水平速度
                    collided: false // 碰撞状态
                };

                config.balls.push(ball);
                config.totalBalls++;
                document.getElementById('totalBalls').textContent = config.totalBalls;

                // 显示释放动画
                releaseIndicator.classList.remove('active');
                setTimeout(() => {
                    releaseIndicator.classList.add('active');
                }, 10);
            }

            // 检测小球与钉子的碰撞
            function checkCollision(ball) {
                // 如果小球还没有到达任何行，从第0行开始检测
                const startRow = Math.max(0, Math.min(ball.row, config.rows - 1));

                // 检查当前行和下一行的钉子
                for (let row = startRow; row <= Math.min(startRow + 1, config.rows - 1); row++) {
                    if (!pegsByRow[row]) continue;

                    for (let i = 0; i < pegsByRow[row].length; i++) {
                        const peg = pegsByRow[row][i];
                        const dx = ball.x - peg.x;
                        const dy = ball.y - peg.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < ball.radius + peg.radius) {
                            // 避免在同一行多次碰撞
                            if (ball.lastCollisionRow === row) {
                                return false;
                            }

                            // 碰撞处理
                            ball.lastCollisionRow = row;
                            ball.row = row + 1;

                            // 添加震动效果
                            const jitterX = (Math.random() - 0.5) * 4; // 水平震动偏移
                            const jitterY = -Math.random() * 2; // 垂直微小反弹

                            // 碰撞后改变方向
                            if (Math.random() < config.bias) {
                                ball.x += config.binWidth * 0.5 + jitterX;
                            } else {
                                ball.x -= config.binWidth * 0.5 + jitterX;
                            }

                            // 添加微小反弹效果
                            ball.y += jitterY;

                            // 标记碰撞状态
                            ball.collided = true;
                            setTimeout(() => {
                                ball.collided = false;
                            }, 50);

                            return true;
                        }
                    }
                }
                return false;
            }

            // 更新小球位置
            function updateBalls() {
                for (let i = config.balls.length - 1; i >= 0; i--) {
                    const ball = config.balls[i];

                    // 应用重力加速度
                    ball.velocityY += config.gravity;
                    ball.y += ball.velocityY * config.speed;

                    // 添加随机水平偏移（增加真实感）
                    if (!ball.collided) {
                        ball.velocityX = (Math.random() - 0.5) * 0.5;
                        ball.x += ball.velocityX;
                    }

                    // 检测与钉子的碰撞
                    checkCollision(ball);

                    // 如果小球到达收集槽位置
                    if (ball.y >= config.binY - ball.radius) {
                        // 找到对应的收集槽
                        const binIndex = Math.floor(ball.x / config.binWidth);
                        const binIndexClamped = Math.max(0, Math.min(binIndex, config.cols - 1));

                        // 更新收集槽计数
                        config.bins[binIndexClamped]++;

                        // 更新最大数量
                        if (config.bins[binIndexClamped] > config.maxBins) {
                            config.maxBins = config.bins[binIndexClamped];
                        }

                        // 移除小球
                        config.balls.splice(i, 1);

                        // 每20个小球更新一次分布图
                        if (config.totalBalls % 20 === 0) {
                            drawDistribution();
                        }
                    }
                }
            }

            // 释放队列中的小球
            function releaseQueuedBalls() {
                const now = Date.now();
                if (config.ballQueue > 0 && config.balls.length < 30 &&
                    now - config.lastReleaseTime > config.releaseInterval) {

                    addBall();
                    config.ballQueue--;
                    queueCount.textContent = config.ballQueue;
                    config.lastReleaseTime = now;
                }
            }

            // 动画循环
            function animate() {
                if (!config.paused) {
                    updateBalls();
                    releaseQueuedBalls();
                    drawBoard();

                    // 自动模式下添加新球到队列
                    if (config.autoMode && config.ballQueue < 5) {
                        config.ballQueue++;
                        queueCount.textContent = config.ballQueue;
                    }
                }

                config.animationId = requestAnimationFrame(animate);
            }

            // 事件监听
            document.getElementById('dropBall').addEventListener('click', () => {
                config.ballQueue++;
                queueCount.textContent = config.ballQueue;
            });

            document.getElementById('drop10Balls').addEventListener('click', () => {
                config.ballQueue += 10;
                queueCount.textContent = config.ballQueue;
            });

            document.getElementById('drop100Balls').addEventListener('click', () => {
                config.ballQueue += 100;
                queueCount.textContent = config.ballQueue;
            });

            document.getElementById('drop500Balls').addEventListener('click', () => {
                config.ballQueue += 500;
                queueCount.textContent = config.ballQueue;
            });

            const autoButton = document.getElementById('startAuto');
            autoButton.addEventListener('click', function () {
                config.autoMode = !config.autoMode;
                this.textContent = config.autoMode ? '停止自动' : '自动释放';
                this.style.background = config.autoMode ? '#ff6b6b' : '#4dccbd';
            });

            // 新增暂停按钮功能
            const pauseButton = document.getElementById('pauseBtn');
            pauseButton.addEventListener('click', function () {
                config.paused = !config.paused;
                this.textContent = config.paused ? '继续' : '暂停';
                this.style.background = config.paused ? '#4dccbd' : '#f7c948';
            });

            document.getElementById('resetBtn').addEventListener('click', function () {
                cancelAnimationFrame(config.animationId);
                initExperiment();
                config.animationId = requestAnimationFrame(animate);
            });

            document.getElementById('ballSpeed').addEventListener('input', function () {
                config.speed = parseInt(this.value);
                document.getElementById('speedValue').textContent = config.speed + 'x';
                document.getElementById('currentSpeed').textContent = config.speed + 'x';
            });

            document.getElementById('pegLayersSlider').addEventListener('input', function () {
                config.rows = parseInt(this.value);
                config.cols = config.rows + 1;
                document.getElementById('layerValue').textContent = config.rows;
                document.getElementById('pegLayers').textContent = config.rows;
                initExperiment();
            });

            document.getElementById('biasSlider').addEventListener('input', function () {
                config.bias = parseFloat(this.value);
                document.getElementById('biasValue').textContent = config.bias.toFixed(2);
                drawDistribution();
            });

            // 初始化并开始动画
            initExperiment();
            animate();

            // 响应窗口大小变化
            window.addEventListener('resize', () => {
                boardCanvas.width = boardCanvas.offsetWidth;
                boardCanvas.height = boardCanvas.offsetHeight;
                distCanvas.width = distCanvas.offsetWidth;
                distCanvas.height = distCanvas.offsetHeight;
                initExperiment();
            });
        });
    </script>
</body>

</html>